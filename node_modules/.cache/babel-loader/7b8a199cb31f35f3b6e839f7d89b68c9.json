{"ast":null,"code":"// IMPORTS\nimport Api from '../../services/KTPApi'; // ACTION TYPES\n\nexport const types = {\n  AUTH_ERROR: 'AUTH_ERROR',\n  AUTH_LOADING: 'AUTH_LOADING',\n  AUTH_SUCCESS: 'AUTH_SUCCESS',\n  AUTH_VALID: 'AUTH_VALID',\n  AUTH_VALIDATE: 'AUTH_VALIDATE',\n  LOAD_MEMBER: 'LOAD_MEMBER',\n  MEMBER_LOADED: 'MEMBER_LOADED',\n  LOGOUT: 'LOGOUT'\n};\n\nconst action = (type, payload) => ({\n  type,\n  payload\n}); // ACTION CREATORS\n// This is where the thunk middleware comes in handy.\n// It allows us to make asynchronous API calls within our action creators,\n// so that we can isolate the handling of our API calls from \n// our React component logic.\n\n\nconst actions = {\n  login: credentials => {\n    return dispatch => {\n      dispatch(action(types.AUTH_LOADING, {}));\n      return Api.login(credentials).then(data => {\n        dispatch(action(types.AUTH_SUCCESS, data));\n        return data;\n      }).catch(err => {\n        dispatch(action(types.AUTH_ERROR, {}));\n        return err.response.data;\n      });\n    };\n  },\n  logout: () => {\n    return dispatch => {\n      dispatch(action(types.LOGOUT, {}));\n      return true;\n    };\n  },\n  register: credentials => {\n    return dispatch => {\n      dispatch(action(types.AUTH_LOADING, {}));\n      return Api.register(credentials).then(data => {\n        dispatch(action(types.AUTH_SUCCESS, data));\n        return data;\n      }).catch(err => {\n        dispatch(action(types.AUTH_ERROR, {}));\n        return err.response.data;\n      });\n    };\n  },\n  validate: () => {\n    // Checks if there is a token in localStorage\n    // If so, it contacts the API to see if the token is still\n    // valid or not.\n    return dispatch => {\n      dispatch(action(types.AUTH_VALIDATE, {}));\n      return Api.validate().then(data => {\n        switch (data.result) {\n          case 'valid':\n            dispatch(action(types.AUTH_VALID, {\n              member: data.member\n            }));\n            break;\n\n          case 'refreshed':\n            dispatch(action(types.AUTH_SUCCESS, {\n              token: data.token,\n              member: data.member\n            }));\n            break;\n\n          default:\n            dispatch(action(types.AUTH_ERROR, {}));\n            break;\n        }\n\n        return data;\n      }).catch(err => {\n        dispatch(action(types.AUTH_ERROR, {}));\n      });\n    };\n  },\n  loadMember: id => {\n    // If a change happens on the server that impacts the logged in user,\n    // that user needs to be able to see those changes as soon as possible.\n    // This function gets called whenever something happens that may affect\n    // the logged in member, so they will be up-to-date at all times.\n    return dispatch => {\n      dispatch(action(types.LOAD_MEMBER, {}));\n      return Api.loadMember(id).then(data => {\n        dispatch(action(types.MEMBER_LOADED, {\n          member: data.member\n        }));\n        return data;\n      }).catch(err => err.response.data);\n    };\n  }\n};\nexport default actions;","map":{"version":3,"sources":["E:/Webpage/KTP/ktp-react/src/redux/auth/actions.js"],"names":["Api","types","AUTH_ERROR","AUTH_LOADING","AUTH_SUCCESS","AUTH_VALID","AUTH_VALIDATE","LOAD_MEMBER","MEMBER_LOADED","LOGOUT","action","type","payload","actions","login","credentials","dispatch","then","data","catch","err","response","logout","register","validate","result","member","token","loadMember","id"],"mappings":"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","sourcesContent":["// IMPORTS\r\nimport Api from '../../services/KTPApi';\r\n\r\n// ACTION TYPES\r\nexport const types = {\r\n  AUTH_ERROR: 'AUTH_ERROR',\r\n  AUTH_LOADING: 'AUTH_LOADING',\r\n  AUTH_SUCCESS: 'AUTH_SUCCESS',\r\n  AUTH_VALID: 'AUTH_VALID',\r\n  AUTH_VALIDATE: 'AUTH_VALIDATE',\r\n  LOAD_MEMBER: 'LOAD_MEMBER',\r\n  MEMBER_LOADED: 'MEMBER_LOADED',\r\n  LOGOUT: 'LOGOUT',\r\n};\r\n\r\nconst action = (type, payload) => ({ type, payload });\r\n\r\n// ACTION CREATORS\r\n// This is where the thunk middleware comes in handy.\r\n// It allows us to make asynchronous API calls within our action creators,\r\n// so that we can isolate the handling of our API calls from \r\n// our React component logic.\r\nconst actions = {\r\n  login: (credentials) => {\r\n    return dispatch => {\r\n      dispatch(action(types.AUTH_LOADING, {}));\r\n      \r\n      return Api.login(credentials).then(data => {\r\n        dispatch(action(types.AUTH_SUCCESS, data));\r\n        return data;\r\n      })\r\n      .catch(err => {\r\n        dispatch(action(types.AUTH_ERROR, {}));\r\n        return err.response.data;\r\n      });\r\n    };\r\n  },\r\n  logout: () => {\r\n    return dispatch => {\r\n      dispatch(action(types.LOGOUT, {}));\r\n      return true;\r\n    };\r\n  },\r\n  register: (credentials) => {\r\n    return dispatch => {\r\n      dispatch(action(types.AUTH_LOADING, {}));\r\n\r\n      return Api.register(credentials).then(data => {\r\n        dispatch(action(types.AUTH_SUCCESS, data));\r\n        return data;\r\n      })\r\n      .catch(err => {\r\n        dispatch(action(types.AUTH_ERROR, {}));\r\n        return err.response.data;\r\n      });\r\n    };\r\n  },\r\n  validate: () => {\r\n    // Checks if there is a token in localStorage\r\n    // If so, it contacts the API to see if the token is still\r\n    // valid or not.\r\n    return dispatch => {\r\n      dispatch(action(types.AUTH_VALIDATE, {}));\r\n\r\n      return Api.validate().then(data => {\r\n        switch (data.result) {\r\n          case 'valid':\r\n            dispatch(action(types.AUTH_VALID, { member: data.member }));\r\n            break;\r\n          case 'refreshed':\r\n            dispatch(action(types.AUTH_SUCCESS, { token: data.token, member: data.member }));\r\n            break;\r\n          default:\r\n            dispatch(action(types.AUTH_ERROR, {}));\r\n            break;\r\n        }\r\n\r\n        return data;\r\n      })\r\n      .catch(err => {\r\n        dispatch(action(types.AUTH_ERROR, {}));\r\n      });\r\n    };\r\n  },\r\n  loadMember: id => {\r\n    // If a change happens on the server that impacts the logged in user,\r\n    // that user needs to be able to see those changes as soon as possible.\r\n    // This function gets called whenever something happens that may affect\r\n    // the logged in member, so they will be up-to-date at all times.\r\n    return dispatch => {\r\n      dispatch(action(types.LOAD_MEMBER, {}));\r\n\r\n      return Api.loadMember(id).then(data => {\r\n        dispatch(action(types.MEMBER_LOADED, { member: data.member }));\r\n        return data;\r\n      })\r\n      .catch(err => err.response.data);\r\n    }\r\n  }\r\n};\r\n\r\nexport default actions;\r\n"]},"metadata":{},"sourceType":"module"}